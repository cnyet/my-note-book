# 这是全新项目的需求文档
> work-agents 一个极具极客感、现代感的网站，包括前台和管理后台两部分。

## 前端部分
> UI参考两个网站：https://checkmarx.dev/ 和 https://clawdbotai.co/

1. 前端UI，分前台WEB和后端管理系统两部分，都有深色和浅色两种模式
   - 前台UI要求
     - 深入分析目标网站的视觉风格、布局结构、交互动效和色彩体系。
     - 基于分析，设计一套具有现代感、深色调背景的前台UI组件库和设计规范。
     - 确保设计在桌面端和移动端均具备优秀的响应式体验。
   - 后台管理UI，的风格，需要登录后才能访问
     - 评估现有后台管理界面的视觉风格和交互逻辑，在其基础上进行优化和统一。
     - 实现基于角色或权限的访问控制，确保所有管理功能均在用户登录认证后方可访问。
     - 提升后台管理的操作效率和用户体验，如表单验证、批量操作、实时反馈等。
2. 前台WEB页面导航栏包括五个页面，每个页面需明确功能、交互和内容管理方式：
   - **home**：展示网站品牌、核心价值与简介。采用极具现代感的深色调背景，融合从目标网站汲取的设计元素（如大图、动态效果、简洁排版）。确保首屏加载速度快，信息传达清晰。
   - **Agents**：一个集成页面，用于展示LobeChat和5个AI秘书。实现可交互的Tab导航栏，用于在不同助手间切换，默认展示LobeChat。每个助手展示区域应包含其图标、名称、简介及核心交互入口。
   - **tools**：分类展示已有的工具集合。每个工具应有清晰的图标、名称、简短描述和访问链接。支持按类别筛选或搜索工具。
   - **labs**：用于展示处于实验阶段的产品，例如小游戏、AI Agent原型等。每个实验产品应有吸引人的展示卡片，包含项目名称、状态（如“实验性”、“预览”）、简要说明和体验入口。
   - **blog**：展示博客文章列表，支持按标签、日期分类和全文搜索。列表页显示文章标题、摘要、发布时间和标签。点击文章进入详情页。提供“编辑”入口，点击后跳转至后台管理的博客编辑界面。
3. 后台管理主要用于以下模块的数据管理，均需实现完整的增删改查（CRUD）功能：
   - 进入后台管理系统需要登录，可注册新账号
   - **Agents管理**：管理5个子agent的数据。可修改前台展示的名称、图标、描述、关联的服务端点等属性。
   - **博客文章管理**：管理博客文章的全生命周期。提供富文本编辑器（支持Markdown），可修改文章标题、内容、排版、标签、分类、发布时间和状态（草稿/发布）。
   - **工具集管理**：管理tools页面的展示信息。可管理工具的名称、描述、图标、分类、链接地址和排序。
   - **实验室产品管理**：管理labs页面的产品展示。可管理实验产品的名称、描述、状态、展示图片/视频、体验链接和排序。
   - **个人账户管理**：管理个人信息，修改密码等


## 后端部分   
1. 设计项目数据库，优化表结构，实现数据高效读写
   - 对现有数据库进行全面的性能分析和瓶颈诊断，识别低效查询和冗余数据。
   - 根据业务实体（如用户、agents、博客文章、工具、实验产品）重新设计规范化或适度反规范化的表结构。
   - 优化索引策略，包括添加复合索引、全文索引以支持搜索功能，并移除无效索引。
   - 设计高效的数据读写模式，考虑引入缓存层（如Redis）来缓存热点数据，并规划数据分片或读写分离方案以应对未来增长。
   - 确保数据库设计支持事务完整性、数据一致性，并制定详细的数据迁移和回滚计划。

2. 后端接口请求服务，满足REST API规范，接口请求和返回格式统一
   - 审查所有现有API端点，确保遵循RESTful设计原则（资源命名、HTTP方法正确使用、状态码准确）。
   - 制定并实施统一的API请求/响应格式规范，包括成功/错误响应结构、分页格式、数据字段命名约定（建议使用驼峰或蛇形命名法）。
   - 实现全局的请求验证、身份认证（JWT）、授权中间件和统一的异常处理机制。
   - 为所有核心API接口编写清晰、详细的OpenAPI/Swagger文档，并确保文档与代码同步更新。
   - 对重构后的接口进行全面的集成测试和性能测试，确保其稳定性、安全性和响应速度。  


## 系统架构要求
1. 先全面分析当前项目的结构、技术架构、功能模块，保持现有的技术架构不变
   - 系统性地分析项目现有代码仓库，梳理其目录结构、技术栈（前端框架、UI库、后端语言、框架、ORM、数据库）、构建工具和部署流程。
   - 绘制当前系统的架构图，明确各功能模块的划分、依赖关系和数据流。
   - 在后续所有重构和开发任务中，严格遵循现有技术选型，不引入未经评估的新框架或库，确保技术栈的延续性和可维护性。

2. 任务原子化拆分，任务完成后需要验证
   - 将上述每一条宏观需求拆解为具体、可执行、可度量的原子任务（例如：“设计AI秘书数据库表”、“实现AI秘书列表查询API”、“开发AI秘书管理页面UI组件”）。
   - 为每个原子任务定义明确的输入、输出、验收标准（DoD）和预计工时。
   - 每个原子任务完成后，必须通过代码审查、单元测试、集成测试或手动验证等方式进行确认，确保其符合需求且质量达标，之后才能进行后续任务。

3. 完全理解开发需求，先规划一份项目的开发计划，并提供3种实现方案对比，推荐最优方案
   - 基于需求分析和任务拆分，制定一份详细的、分阶段的开发计划，包括各阶段的里程碑、交付物、资源安排和风险应对策略。
   - 针对关键或复杂的模块（如数据库重构、前后端通信方案），设计至少3种不同的技术实现方案。
   - 从**开发效率、性能表现、可维护性、团队熟悉度、长期扩展性**等多个维度对方案进行对比分析，形成清晰的对比表格。
   - 基于对比分析，给出明确的**最优方案推荐**，并阐述推荐理由。

4. 按需调用本地的agent, skill, mcp能力
   - 在开发过程中，识别那些可以通过现有本地AI能力（如代码生成Agent、代码审查Skill、项目上下文MCP）来提升效率的环节。
   - 明确这些能力的调用时机、输入格式和预期输出，并将其集成到开发工作流中。
   - 例如，在编写重复性代码、生成测试用例、进行代码审查或理解复杂模块时，主动调用相应的本地能力进行辅助。
